# pragma once

在 C/C++ 中，在使用预编译指令`#include`的时候，为了防止重复引用造成二义性，通常有两种方式

:::tip
你也可以完全不考虑二义性，仅仅凭借自己智慧的大脑和严谨的逻辑链保证你的引用是完全唯一的
:::

第一种是`#ifndef`指令防止代码块重复引用，比如说

```cpp
#ifndef _CODE_BLOCK
#define _CODE_BLOCK
// code
#endif // _CODE_BLOCK
```
:::tip
注意，`_CODE_BLOCK`应是一个独一无二的宏名，否则会有编译错误
:::

## ifndef

`#ifndef`方式是 C/C++ 语言的标准支持，也是比较常用的方式，`#ifndef`的方式依赖于自定义的宏名（例中的`_CODE_BLOCK`）不能冲突，它不光可以保证同一份文件不会被包含两次，也能够保证*不同文件完全相同的内容*不会被包含两次。

但同样的，如果自定义的宏名不小心“重名”了，两份不同的文件使用同一个宏名进行`#ifndef`，那么会导致编译器找不到声明的情况（被编译器判定为重定义而屏蔽了）。

此外，由于编译器每次都需要打开头文件才能判定是否有重复定义，因此在编译大型项目时，`#ifndef`会使得编译时间相对较长，因此一些编译器逐渐开始支持`#pragma once`的方式（Visual Studio 2017新建头文件会自带`#pragma once`指令）。

第二种就是`#pragma once`指令，在想要保护的文件开头写入


## pragma once
`#pragma once`一般由编译器提供保证：同一个文件不会被包含多次。

这里所说的"同一个文件"是指物理上的一个文件，而不是指内容相同的两个文件。无法对一个头文件中的一段代码作`#pragma once`声明，而只能针对文件。

此方式不会出现宏名碰撞引发的奇怪问题，大型项目的编译速度也因此提供了一些。缺点是如果某个头文件有多份拷贝，此方法不能保证它们不被重复包含。

::: tip
在C/C++中，`#pragma once`是一个非标准但是被广泛支持的方式。
:::

## 相互关系
`#pragma once`方式产生于`#ifndef`之后。

`#ifndef`方式受 C/C++ 语言标准的支持，不受编译器的任何限制；而`#pragma once`方式有些编译器不支持(较老编译器不支持，如GCC 3.4版本之前不支持`#pragma once`)，兼容性不够好。

`#ifndef`可以针对一个文件中的部分代码，而`#pragma once`只能针对整个文件。

相对而言，`#ifndef`更加灵活，兼容性好，`#pragma once`操作简单，效率高。

## 推荐操作
为了在各个编译环境都能做到成功编译，可以将两个放在一起，如

```cpp
#pragma once
#ifndef _CODE_BLOCK
#define _CODE_BLOCK
// code
#endif // _CODE_BLOCK
```

这样是良好的编程习惯，可以提高编译速度同时也可以防止不兼容