# 头文件

## 什么是头文件（.h）

头文件是扩展名为`.h`的文件，与源文件`.cpp`一样，头文件中也是 C++ 的源代码，头文件中包含了 C++ 中函数、类、对象等的声明和宏定义，它可以被多个源文件通过`#include`引用共享。


## 头文件的价值

一个事物存在，必有其存在的价值和意义，头文件也一样。

C++中有“单一定义”规则，即“一个对象只能被定义一次”

如果在一个源文件中定义了一个函数，其他的源文件想要使用这个函数就需要在使用前声明一下这个函数，在编译结束之后，编译器链接的时候再去查找这些函数的定义。

当只有一两个函数，源文件的数目也不多的时候，我们完全可以直接在源文件中声明这些函数或者变量。但是当我们面临一个大的项目时，几百个函数，非常多的变量，100个源文件。如果每个函数都在每个源文件中声明。那就太麻烦太费事了。

所以，为了达到在不同的源文件中声明的一致性，为了省去这些繁琐又重复的过程，我们可以把这些对象的声明都放在少数几个文件中，需要用到这些声明的时候再到这些文件中查找，这样的文件，就是头文件。


## 头文件的分类

按照来源的不同，有两种类型的头文件：
- 程序员编写的头文件
  
  使用方法为`"fileName"`
  ```cpp
  #include "我是自己写的头文件.h"
  ```
- 标准库（编译器或者其他库的头文件）
  
  这里使用的符号与自己写的不同，用`<fileName>`
  ```cpp
  #include <iostream>
  ```


## 编译过程中的头文件

C++代码的编译主要通过以下几个过程：

预编译->编译->链接，最后生成可执行文件。        

::: warning
切记，头文件是不参与编译的，编译器只对源文件进行编译
:::

编译器首先对源文件进行预处理，这一步叫预编译。预编译的时候完成头文件中的宏的处理，并且根据`#include`指令将头文件展开

头文件的编译是有要求的，一不小心就会出现不可预料的问题，所以要使用宏声明[#pragma once](pragma%20once.md)

我们看一个简单的例子，下面是一个头文件`CA.h`

```cpp{3}
#ifndef CA_H
#define CA_H
  int Fun();
#endif
```

:::tip
你看到的高亮区域是一个头文件必不可少的内容，而上下的`ifndef`等等实际上是保证头文件不会多次重复声明所建设的保护性机制，其属于宏的知识框架
:::

有两个源文件`A.cpp`与`B.cpp`都包含了`CA.h`


```cpp
// A.cpp
#include "CA.h"
int Fun() {
    return 1;
}
```

```cpp
// B.cpp
#include "CA.h"
int Fun1() {
    return Fun() + 1;
}
``` 

经过预编译后，这两个源文件分别变为
```cpp
// 预编译 A.cpp
#ifndef CA_H
#define CA_H
  int Fun();
#endif

int Fun() {
    return 1;
}
```

```cpp
#ifndef CA_H
#define CA_H
  int Fun();
#endif

int Fun1() {
    return Fun() + 1;
}
```

这样就实现了在`A.cpp`与`B.cpp`中对函数`int Fun()`的声明。

在上面的例子中，`A.cpp`与`B.cpp`所承担的功能是不一样的，我们在`CA.h`中声明了`Fun`函数的存在，但是实际上并没有对`Fun`函数的实现进行任何的描述，所以在`A.cpp`中，我们在函数`Fun`声明之后实现了函数`Fun`的定义，在此时`Fun`函数才有明确的指向位置。

之后在`B.cpp`中，我们将已经链接完毕的`Fun`函数给到`Fun1`函数，此处给一个函数声明即可，编译器会自己把`Fun`函数运行本体链接上`Fun1`函数

## 建议
使用基本的头文件命名格式，`文件名`和文件内的`函数名`一致

::: tip
如果你学习了面向对象，那么下面的建议会对你有很大帮助
:::
一个类使用一个头文件，每个头文件仅仅有一个类的声明

将一个类对应的源代码命名成头文件的格式